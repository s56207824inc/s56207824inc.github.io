<html>
    <head>
        <title>Branch Test</title>
        <script src='https://cdn.jsdelivr.net/npm/winwheeljs@2.7.0/dist/Winwheel.min.js'></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>
        <style>
           
          .container{
            width: 100%;
            height: 100vh;
            display: flex;
          }
          #map{
              width: 50%;
              height: 100vh;
          }
          #canvas{
              width: 50%;
              height: 50%;
          }

      </style>
    </head>
    <body>
      {% load static %}
      <!-- TODO:前端切版、排版CSS -->
      <div class="container">
        <div id="map" ></div>
        <canvas id="canvas" 
        width="880" height="440"  style="z-index: 3;"
          data-responsiveMinWidth="180"
          data-responsiveScaleHeight="true"   
          data-responsiveMargin="50"
          onclick="startSpin()">
        </canvas>
      </div>
      
      <audio id="myAudio"> 
        <source src="{% static '/media/tick.mp3' %}" type="audio/mpeg">
        Your browser does not support the audio element.
      </audio>


      <!-- TODO: 如果其中有一個格子沒有值的話, 需要提示-->
      <div class="wrap">
        <div class="search">
        <input class="search-bar" type="text" name="search" id="distance" placeholder="多少距離之內">
        </div>
      </div>
      <!-- TODO: 按鈕、搜尋樣式改好看-->
      <div class="wrap">
          <div class="search">
          <input class="search-bar" type="text" name="search" id="mylocation" placeholder="目前位置">
          <button class="search-btn" id="btn" onclick="cal()"></button>
          </div>
      </div>


      <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAlNRaHqtGB3sTDKymkHmJtYRfPFpfFVsU&libraries=places&callback=initMap"></script>
      <!-- <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAt4ZfNINLe9AQgtPoUYkRv_P_tvifCCHM&callback=initMap&libraries=places" async defer></script> -->

      <!-- draw the whole wheels -->
      <!-- TODO:JS 包起來 -->
      <script>
          let theWheel;
          let colorMap = [
            '#eae56f',
            '#e7706f',
            '#7de6ef',
          ]

          function drawTheWheel(numberValid) {
              delete theWheel;
              const numSegments = numberValid;
              let segments = [];
              // TODO:輪盤樣式、顏色改好看一點
              for (let i = 0; i < numSegments; i++) {
                    let colorIndex = (i % colorMap.length);
                    let segmentInfo = {'fillStyle': colorMap[colorIndex], 'text': Info[i].placeName};
                    segments.push(segmentInfo)
              }

              theWheel = new Winwheel({
                  'numSegments'  : numSegments,
                  'textFontSize' : 14,
                  'responsive'   : true,  // This wheel is responsive!
                  'pointerAngle' : 90,    // Ensure this is set correctly
                  'segments'     : segments,
                  'animation' :
                  {
                      'type'     : 'spinToStop',
                      'duration' : 5,
                      'spins'    : 8,
                      'callbackSound' : 'playSound()' , 
                      'soundTrigger'  : 'pin',
                      'callbackFinished' : 'alertPrize()',
                      'callbackAfter' : 'drawTriangle()',
                  },
                  'pins' :
                  {
                      'number' : 16,
                      'outerRadius': 6,
                      'responsive' : true, // This must be set to true if pin size is to be responsive.
                  }
              });
              
              drawTriangle();
            }


          function drawTriangle() {
              // Get the canvas context the wheel uses.
              let ctx = theWheel.ctx;

              ctx.strokeStyle = 'navy';     // Set line colour.
              ctx.fillStyle   = 'aqua';     // Set fill colour.
              ctx.lineWidth   = 2;
              ctx.beginPath();              // Begin path

              // degree 45
              ctx.moveTo(670, 194);      // Move to initial position.
              ctx.lineTo(670, 246);      // Draw lines to make the shape.
              ctx.lineTo(630, 220);
              ctx.lineTo(670, 195);
              ctx.stroke();                 // Complete the path by stroking (draw lines).
              ctx.fill();                   // Then fill.
          }
      </script>


      <!-- wheels utilis -->
      <script>
          function startSpin() {
              theWheel.stopAnimation(false);
              theWheel.rotationAngle = theWheel.rotationAngle % 360;
              theWheel.startAnimation();
          }


          function alertPrize() {
              let winningSegment = theWheel.getIndicatedSegment();
              playSound();
              alert("You have won " + winningSegment.text + "!");
          }

          let audio = document.getElementById("myAudio");
          function playSound() {
              audio.pause();
              audio.currentTime = 0;
              audio.play();
          }
      </script>


      <script>
          var map, infoWindow;
          function initMap() {
              map = new google.maps.Map(document.getElementById("map"), {
                  center: { lat: 23.5, lng: 121 },
                  zoom: 8,
              });

              infoWindow = new google.maps.InfoWindow();
        }

                
        window.initMap = initMap;
        let dis, myloc, geocoder;
        let pos, service;
        let Info = [];
        const DEFAULT_NUM = 5;
         
        class placeInfo {
            constructor() {
                this.placeName = "None";
                this.distanceFrom = 0;
            }
        }


        for(let i=0; i<DEFAULT_NUM; i++) {
            Info.push(new placeInfo());
        }
        drawTheWheel(DEFAULT_NUM);


        function cal() {
            // TODO:若dis或myloc為空，跳錯誤通知
            // TODO:若dis不是數字或非有效值，報錯
            // TODO:若myloc結果非有效值，報錯
            // TODO:距離算法(DRIVING/WALKING/...)讓使用者選擇
            dis = document.getElementById("distance").value;
            myloc = document.getElementById("mylocation").value;
            
            geocoder = new google.maps.Geocoder();
            geocoder.geocode({
                'address': myloc
                }, 
                function(results, status) {
                    // console.log(results[0].geometry.location.lng())
                    if (status == 'OK') {
                        map.setCenter(results[0].geometry.location);
                        map.setZoom(16);
                        var marker = new google.maps.Marker({
                            map: map,
                            position: results[0].geometry.location
                        });
                        pos = {
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng()
                        };
                        getNearbyPlaces(pos);
                        console.log(Info);
                    } else {
                        console.log(status);
                    }
                });
        }

        
        function getNearbyPlaces(position) {
            console.log('call getNearbyPlaces')
            let request = {
                location: position,
                rankBy: google.maps.places.RankBy.DISTANCE, //依照距離排列
                keyword: 'restaurant'
            };
            service = new google.maps.places.PlacesService(map);
            service.nearbySearch(request, nearbyCallback);
        }


        function nearbyCallback(places, status) {
            console.log('call nearbyCallback')
            let destination = [];
            Info = [];
            if (status == google.maps.places.PlacesServiceStatus.OK) {
                places.forEach(place => {
                    let currLocation = new google.maps.LatLng(place.geometry.location.lat(), 
                                                              place.geometry.location.lng());
                    let instance = new placeInfo()
                    instance.placeName = place.name;
                    Info.push(instance);
                    destination.push(currLocation);
                });
                calculateDistance(destination);
            }
        }


        function calculateDistance(destination) {
            console.log('call calculateDistance')
            const serviceForDistance = new google.maps.DistanceMatrixService();
            serviceForDistance.getDistanceMatrix(
                {
                    origins: [pos],
                    destinations: destination,
                    travelMode: 'DRIVING',
                    unitSystem: google.maps.UnitSystem.METRIC,
                    avoidHighways: true,
                    avoidTolls: true,
                }, testCallBack);
        }


        function testCallBack(results, status) {
          console.log('call testCallBack')
            for (let i = 0; i < results.rows[0].elements.length; i++) {
                Info[i].distanceFrom = results.rows[0].elements[i].distance.value;
            }
            Info.sort(function(a, b) {
                return a.distanceFrom > b.distanceFrom ? 1 : -1; ///????
            });


            let numberValid = 0
            for (let i = 0; i < Info.length; i++) {
                if (Info[i].distanceFrom < dis) {
                  Info[numberValid] = Info[i];
                  numberValid += 1
                } 
            }

            console.log(numberValid)
            drawTheWheel(numberValid)
            
        }
      </script>

  
    </body>
</html>