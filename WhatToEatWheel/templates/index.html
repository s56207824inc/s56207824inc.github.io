<html>
    <head>
        <title>Branch Test</title>
        <script src='https://cdn.jsdelivr.net/npm/winwheeljs@2.7.0/dist/Winwheel.min.js'></script>
        <script src="http://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>
        <style>
          .container{
            width: 100%;
            height: 100vh;
            display: flex;
          }
          #map{
              width: 50%;
              height: 100vh;
          }
          #canvas{
              width: 50%;
              height: 50%;
          }

      </style>
    </head>
    <body>
      <!-- {% load static %} -->
      <div class="container">
        <div id="map" ></div>
        <canvas id="canvas" 
        width="880" height="440"  style="z-index: 3;"
          data-responsiveMinWidth="180"
          data-responsiveScaleHeight="true"   
          data-responsiveMargin="50"
          onclick="startSpin()">
        </canvas>
      </div>
      
      <audio id="myAudio"> 
        <source src="{% static '/media/tick.mp3' %}" type="audio/mpeg">
        Your browser does not support the audio element.
      </audio>
      <button onclick="startSpin()" type="button">Play Audio</button>




      <!-- TODO: 如果其中有一個格子沒有值的話, 需要提示-->
      <div class="wrap">
        <div class="search">
        <input class="search-bar" type="text" name="search" id="distance" placeholder="多少距離之內">
        </div>
      </div>

      <div class="wrap">
          <div class="search">
          <input class="search-bar" type="text" name="search" id="mylocation" placeholder="目前位置">
          <button class="search-btn" id="btn" onclick="cal()"></button>
          </div>
      </div>


      <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAlNRaHqtGB3sTDKymkHmJtYRfPFpfFVsU&libraries=places&callback=initMap"></script>
      <!-- <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAt4ZfNINLe9AQgtPoUYkRv_P_tvifCCHM&callback=initMap&libraries=places" async defer></script> -->

      <!-- draw the whole wheels -->
      <script>
          let theWheel;
          function drawTheWheel(numberValid) {
              const numSegments = numberValid;
              let segments = [];
              
              function getRandomColor() {
                  let color = [];
                  for (let i = 0; i < 3; i++) {
                      let asciiNum = Math.ceil(Math.random() * 5);
                      color.push(String.fromCharCode(97 + asciiNum));
                  }
                  for (let i = 0; i < 3; i++) {
                      let radNum = Math.ceil(Math.random() * 9);
                      color.push(String.fromCharCode(48 + radNum));
                  }
                  return color.join('');
              }

              for (let i = 0; i < numSegments; i++) {
                    console.log(getRandomColor())
                    let segmentInfo = {'fillStyle': '#' + getRandomColor(), 'text': Info[i].placeName};
                    segments.push(segmentInfo)
              }

              theWheel = new Winwheel({
                  'numSegments'  : numSegments,
                  'textFontSize' : 14,
                  'responsive'   : true,  // This wheel is responsive!
                  'pointerAngle' : 90,    // Ensure this is set correctly
                  'segments'     : segments,
                  'animation' :
                  {
                      'type'     : 'spinToStop',
                      'duration' : 5,
                      'spins'    : 8,
                      'callbackSound' : 'playSound()' , 
                      'soundTrigger'  : 'pin',
                      'callbackFinished' : 'alertPrize()',
                      'callbackAfter' : 'drawTriangle()',
                  },
                  'pins' :
                  {
                      'number' : 16,
                      'outerRadius': 6,
                      'responsive' : true, // This must be set to true if pin size is to be responsive.
                  }
              });
              drawTriangle();
            }


          function drawTriangle() {
              // Get the canvas context the wheel uses.
              let ctx = theWheel.ctx;

              ctx.strokeStyle = 'navy';     // Set line colour.
              ctx.fillStyle   = 'aqua';     // Set fill colour.
              ctx.lineWidth   = 2;
              ctx.beginPath();              // Begin path

              // degree 45
              ctx.moveTo(670, 194);      // Move to initial position.
              ctx.lineTo(670, 246);      // Draw lines to make the shape.
              ctx.lineTo(630, 220);
              ctx.lineTo(670, 195);
              ctx.stroke();                 // Complete the path by stroking (draw lines).
              ctx.fill();                   // Then fill.
          }
      </script>


      <!-- wheels utilis -->
      <script>
          function startSpin() {
              theWheel.stopAnimation(false);
              theWheel.rotationAngle = theWheel.rotationAngle % 360;
              theWheel.startAnimation();
          }


          function alertPrize() {
              let winningSegment = theWheel.getIndicatedSegment();
              playSound();
              alert("You have won " + winningSegment.text + "!");
          }

          let audio = document.getElementById("myAudio");
          function playSound() {
              audio.pause();
              audio.currentTime = 0;
              audio.play();
          }
      </script>


      <script>
          var map, infoWindow;
          function initMap() {
              map = new google.maps.Map(document.getElementById("map"), {
                  center: { lat: -34.397, lng: 150.644 },
                  zoom: 16,
              });

              infoWindow = new google.maps.InfoWindow();
              const locationButton = document.createElement("button");

              locationButton.textContent = "Pan to Current Location";
              locationButton.classList.add("custom-map-control-button");
              map.controls[google.maps.ControlPosition.TOP_CENTER].push(locationButton);
              locationButton.addEventListener("click", () => {
              if (navigator.geolocation) {
                  navigator.geolocation.getCurrentPosition(
                    (position) => {
                      const pos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                      };
                      infoWindow.setPosition(pos);
                      infoWindow.setContent("Location found.");
                      infoWindow.open(map); 
                      map.setCenter(pos);
                    },
                    () => {
                        handleLocationError(true, infoWindow, map.getCenter());
                    }
                ); 
              } else {
                  // Browser doesn't support Geolocation
                  handleLocationError(false, infoWindow, map.getCenter());
              }


          function handleLocationError(browserHasGeolocation, infoWindow, pos) {
              infoWindow.setPosition(pos);
              infoWindow.setContent(
                  browserHasGeolocation
                  ? "Error: The Geolocation service failed."
                  : "Error: Your browser doesn't support geolocation."
              );
              infoWindow.open(map);
          }

          var service = new google.maps.places.PlacesService(map);
          service.findPlaceFromQuery(request, function(results, status) {
              if (status === google.maps.places.PlacesServiceStatus.OK) {
                  console.log(results[0].geometry);
                  map.setCenter(results[0].geometry.location);
              }
          });
          });
        }

                
        window.initMap = initMap;
        let dis, myloc, geocoder;
        let pos, service;
       
        class placeInfo {
            constructor() {
                this.placeName = "None";
                this.distanceFrom = 0;
            }
        }
        
        let finish = false;
        function cal() {
            dis = document.getElementById("distance").value;
            myloc = document.getElementById("mylocation").value;
            geocoder = new google.maps.Geocoder();
            geocoder.geocode({
                'address': myloc
                }, 
                function(results, status) {
                    // console.log(results[0].geometry.location.lng())
                    if (status == 'OK') {
                        map.setCenter(results[0].geometry.location);
                        var marker = new google.maps.Marker({
                            map: map,
                            position: results[0].geometry.location
                        });
                        pos = {
                            lat: results[0].geometry.location.lat(),
                            lng: results[0].geometry.location.lng()
                        };
                        getNearbyPlaces(pos);
                    } else {
                        console.log(status);
                    }
                });
        }

        let Info = [];
        function getNearbyPlaces(position) {
            console.log('call getNearbyPlaces')
            let request = {
                location: position,
                rankBy: google.maps.places.RankBy.DISTANCE, //依照距離排列
                keyword: 'restaurant'
            };
            service = new google.maps.places.PlacesService(map);
            service.nearbySearch(request, nearbyCallback);
        }


        function nearbyCallback(places, status) {
            console.log('call nearbyCallback')
            let destination = [];
            if (status == google.maps.places.PlacesServiceStatus.OK) {
                places.forEach(place => {
                    let currLocation = new google.maps.LatLng(place.geometry.location.lat(), 
                                                              place.geometry.location.lng());
                    let instance = new placeInfo()
                    instance.placeName = place.name;
                    Info.push(instance);
                    destination.push(currLocation);
                });
                calculateDistance(destination);
            }
        }


        function calculateDistance(destination) {
            console.log('call calculateDistance')
            const serviceForDistance = new google.maps.DistanceMatrixService();
            serviceForDistance.getDistanceMatrix(
                {
                    origins: [pos],
                    destinations: destination,
                    travelMode: 'DRIVING',
                    unitSystem: google.maps.UnitSystem.METRIC,
                    avoidHighways: true,
                    avoidTolls: true,
                }, testCallBack);
        }


        function testCallBack(results, status) {
          console.log('call testCallBack')
            for (let i = 0; i < results.rows[0].elements.length; i++) {
                Info[i].distanceFrom = results.rows[0].elements[i].distance.value;
            }
            Info.sort(function(a, b) {
                return a.distanceFrom > b.distanceFrom ? 1 : -1; ///????
            });


            let numberValid = 0
            for (let i = 0; i < Info.length; i++) {
                if (Info[i].distanceFrom < dis) {
                  Info[numberValid] = Info[i];
                  numberValid += 1
                } 
            }

            console.log(numberValid)
            drawTheWheel(numberValid)
            
        }
      </script>

  
    </body>
</html>